import os, sys, json, time

class ejector:
  def __init__(self, eject_type):
    self.eject_type = eject_type
    self.write_to = ""
    self.upd_file_with = ""
    self.port = ""
    self.path = ""
    self.dir_path = ""
    self.abs_path = ""
    self.CACHE_FILE = ""
    self.use_to_upd = ""
  
  def getPort(self, port_name):
    self.port = port_name
    self.upd_file_with = []
    self.upd_file = []
    self.upd_with_error = ""
    self.warning_FOR_USER = ""
    self.exact = ""
    self.file_OPENED = ""
    self.file_OPENED_read = ""

    if os.path.exists('/home/runner/eject_type_info.txt'):

      if not '[[' in open('eject_type_info.txt','r').read():
        with open('eject_type_info.txt','w') as file:
          self.upd_file_with.append([f'EJECTION_{self.eject_type}'])

          a = json.dumps(self.upd_file_with)
                
          self.upd_file.append([f'WITH_PORT_{self.port}'])

          b = json.dumps(self.upd_file)

          self.upd_with_error= '\n\n--THIS_MSG_WILL_BE_DELETED_AT_NEXT_APPLICATION_RUNTME--\n\n##-STATUS_CORRUPTED_WITH_NEW_STATUS_FIXED-##'

          file.write(a)
          file.write('\n')
          file.write(b)
          file.write('\n')
          file.write(self.upd_with_error)
          file.close()
        
        print('FIXING CORRUPTED FILE...')
        time.sleep(5)

        raise Exception("The file: eject_type_info.txt -- is corrupted @ syntax \"[[\"\nFIXED AT 6 SECONDS")
      
      if not ']]' in open('eject_type_info.txt','r').read():
        with open('eject_type_info.txt','w') as file:
          self.upd_file_with.append([f'EJECTION_{self.eject_type}'])

          a = json.dumps(self.upd_file_with)
                
          self.upd_file.append([f'WITH_PORT_{self.port}'])

          b = json.dumps(self.upd_file)

          file.write(a)
          file.write('\n')
          file.write(b)
          file.close()
        
        print('FIXING CORRUPTED FILE...')
        time.sleep(5)

        raise Exception("The file: eject_type_info.txt -- is corrupted @ syntax \"]]\"\nFIXED AT 6 SECONDS")

    if os.path.exists('/home/runner/connection.txt'):
      if self.port in open('connection.txt','r').read():
        with open('eject_type_info.txt','w') as file:
          self.warning_FOR_USER = "!!! PLEASE DO NOT EDIT THIS FILE !!!\n\n\n"

          self.upd_file_with.append([f'EJECTION_{self.eject_type}'])

          a = json.dumps(self.upd_file_with)
                
          self.upd_file.append([f'WITH_PORT_{self.port}'])

          b = json.dumps(self.upd_file)

          file.write(self.warning_FOR_USER)
          file.write('\n')
          file.write(a)
          file.write('\n')
          file.write(b)
          file.close()
  
  def enterPath(self, path, CACHE_FILE, use_to_upd):
    # self.path = path
    self.abs_path = path
    self.CACHE_FILE = CACHE_FILE
    self.use_to_up = use_to_upd

    if os.path.exists(self.abs_path):
      import sqlite3
      os.system(f'cd && cd {self.path} && ls')

      file_ = input('\n.db file >> ')

      if not os.path.exists(file_):
        raise Exception('file does not exists')
        return "Exited with error with exit status {}".format(1078)

      # No reason as to why we have self.exact. Possibly for possible future errors with self.path?
      # TODO: Can we use self.exact later for a actual purpose that of what self.path cannot succeed?
      self.exact = file_

      # This will be used as the renderer for opening the .db file to write into
      # NOTE: This flexuates. Look AT line 92 and notice we re-assigned the self.path value below:
      self.path = file_

      with open(f'{self.path}','w') as file:

        connect = sqlite3.connect(self.path)
        crs = connect.cursor()

        type_ = input('\n'+f'1: Implement with application \n$USER$ >> ')
        
        if type_ == '1':
          
          with open(self.path,'w') as file:
            file.write(f'{self.upd_file_with}'+'<>'+f'STATUS_PORT_{self.port}')
            
            # WRITING WITH SQL
            crs.execute(open('TABLE.sql','r').read())
            if 'TABLE' or 'table' in open(self.path,'r').read():

              print('\nDATA INSERTED: \n{}'.format(open('TABLE.sql','r').read()))

              add_more = input('Alter table(add anything) [y/n] >> ')

              if add_more == 'y' or add_more == 'Y':
                ROW_NAME = input('$USER$ Column Name >> ')
                TYPE = input('$USER$ Row Type(INTEGER,TEXT) >> ')

                if TYPE == 'TEXT' or TYPE == 'INTEGER':
                  ALTER = f"""
ALTER TABLE DATABASE_
ADD COLUMN {ROW_NAME} {TYPE}
                  """
                  crs.execute(ALTER)

            crs.fetchall()
            # CLOSING SECURED FILE
            file.close()
        
        if type_ == '':
          raise IOError('Error @ syntax: User did not give input value')
          return "Error with exit status {}".format(1078)
        
        if not type_ == '' and not type_ == '1':
          raise  Exception('User did not input a valid identifier for the application to compile')
          return "Error @ syntax: No valid input validator for application_compiler. Exit status {}".format(1078)
 
        # establishing sql enjection/ejection
        connect.commit()
        connect.close()

    else:
      time.sleep(2)
      print('\nNo such directory: {}'.format(self.abs_path))
