import os, sys, json, time

class ejector:
  def __init__(self, eject_type):
    self.eject_type = eject_type
    self.write_to = ""
    self.upd_file_with = ""
    self.port = ""
    self.path = ""
    self.dir_path = ""
  
  def getPort(self, port_name):
    self.port = port_name
    self.upd_file_with = []
    self.upd_file = []
    self.upd_with_error = ""
    self.warning_FOR_USER = ""

    if os.path.exists('/home/runner/eject_type_info.txt'):

      if not '[[' in open('eject_type_info.txt','r').read():
        with open('eject_type_info.txt','w') as file:
          self.upd_file_with.append([f'EJECTION_{self.eject_type}'])

          a = json.dumps(self.upd_file_with)
                
          self.upd_file.append([f'WITH_PORT_{self.port}'])

          b = json.dumps(self.upd_file)

          self.upd_with_error= '\n\n--THIS_MSG_WILL_BE_DELETED_AT_NEXT_APPLICATION_RUNTME--\n\n##-STATUS_CORRUPTED_WITH_NEW_STATUS_FIXED-##'

          file.write(a)
          file.write('\n')
          file.write(b)
          file.write('\n')
          file.write(self.upd_with_error)
          file.close()
        
        print('FIXING CORRUPTED FILE...')
        time.sleep(5)

        raise Exception("The file: eject_type_info.txt -- is corrupted @ syntax \"[[\"\nFIXED AT 6 SECONDS")
      
      if not ']]' in open('eject_type_info.txt','r').read():
        with open('eject_type_info.txt','w') as file:
          self.upd_file_with.append([f'EJECTION_{self.eject_type}'])

          a = json.dumps(self.upd_file_with)
                
          self.upd_file.append([f'WITH_PORT_{self.port}'])

          b = json.dumps(self.upd_file)

          file.write(a)
          file.write('\n')
          file.write(b)
          file.close()
        
        print('FIXING CORRUPTED FILE...')
        time.sleep(5)

        raise Exception("The file: eject_type_info.txt -- is corrupted @ syntax \"]]\"\nFIXED AT 6 SECONDS")

    if os.path.exists('/home/runner/connection.txt'):
      if self.port in open('connection.txt','r').read():
        with open('eject_type_info.txt','w') as file:
          self.warning_FOR_USER = "!!! PLEASE DO NOT EDIT THIS FILE !!!\n\n\n"

          self.upd_file_with.append([f'EJECTION_{self.eject_type}'])

          a = json.dumps(self.upd_file_with)
                
          self.upd_file.append([f'WITH_PORT_{self.port}'])

          b = json.dumps(self.upd_file)

          file.write(self.warning_FOR_USER)
          file.write('\n')
          file.write(a)
          file.write('\n')
          file.write(b)
          file.close()
  
  def enterPath(self, path):
    self.path = path

    if os.path.exists(self.path):
      import sqlite3
      os.system(f'cd && cd {self.path} && ls')

      file_ = input('\n.db file >> ')
      self.path = file_
      with open(f'{self.path}','w') as file:

        connect = sqlite3.connect(self.path)
        crs = connect.cursor()

        type_ = input('\n'+f'Want to write a already existing .sql file into {self.path} to pull request or eject sql from application? [1 for already existing, 2 for application ejection] >> ')

        if type_ == '1':
          other_dir = input('\nDirectory of existing .sql >> ')
          os.system(f'cd && cd {other_dir} && ls')
          file_NAME = input('\n.sql FILE NAME >> ')
          if not '.sql' in file_NAME:
            raise Exception(f'Error @ syntax "{file_NAME}"')
          elif '.sql' in file_NAME:
            if os.path.exists(f'{other_dir}/{file_NAME}'):
              open_file = open(file_NAME,'r')

              with open(self.path,'w') as file:
                file.write(f'{self.upd_file_with}')
                crs.execute(open_file.read())
                crs.fetchall()

          else:
            time.sleep(2)
            print('\nNo such directory')

        connect.commit()
        connect.close()

    else:
      time.sleep(2)
      print('\nNo such directory')
